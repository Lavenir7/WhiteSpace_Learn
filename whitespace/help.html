<style type="text/css">
  @import "css/help.css";
</style>
<html>
<a id="top"></a>
<div name="toc">
o <a href="#about">[About]</a>
o <a href="#new">[What's New]</a>
o <a href="#whitespace">[Whitespace]</a>
o <a href="#assembly">[Assembly]</a>
o <a href="#optimizer">[Optimizer]</a>
</div>
<div>
<a id="about"/>
About <a href="#top">[top]</a>
=====

Whitelips is an online IDE for Whitespace.

<a id="new">
What's New? <a href="#top">[top]</a>
===========
Version 0.13.1
  - Links in "about" tab open in a new window.
  - Memory tab is updated only when visible.
  - Interpreter is way faster with fewer interruptions.
===========
Version 0.13.0:
  - Memory can now hold arbitrary length values (BigInt).
  - Added Malbolge interpreter and sample files.
  - Added "about" tab for program descriptions.
===========
Version 0.10.1:
  - Support for virtual machines. See vm/bf.ws.
  - Support for compilers. See wc/bf2wsa.ws.
  - New icons.
  - Optional parameters for asm keywords - parameter is added using a push.
  - Some bug fixes.
  - EOF is interpreted as "no change".

Whitespace <a href="#top">[top]</a>
==========
Whitespace is a language that does not force you to add semicolons at the end of
statements!

<a id="assembly" />
Assembly <a href="#top">[top]</a>
========

As there is no official standard, Whitelips features it's own assembly
language. Care has been taken to make it compatible with others, but
this has never been a goal.
</div>
<div>
  push     $n - Push value $n onto the stack.
  dup         - Duplicate the topmost stack element.
  copy     $n - copies the $n-th element from stack, where 0 is the topmost
                value.
  swap        - swap two topmost stack elements.
  drop        - discards the topmost stack value.
  slide    $n - keeps the topmost element, and deletes the next $n elements.
  add         - consume the two topmost elements and push their sum.
                +---+
                | b |
                +---+  ==> +-------+
                | a |      | a + b |
                +---+      +-------+
  sub         - subrtact the topmost value from the next one and push the result back.
                +---+
                | b |
                +---+  ==> +-------+
                | a |      | a - b |
                +---+      +-------+
  mul         - consume and multiply the two topmost elements and push the result back.
                +---+
                | b |
                +---+  ==> +-------+
                | a |      | a * b |
                +---+      +-------+
  div         - Divide the second value by the topmost element and push the value back.
                +---+
                | b |
                +---+  ==> +-------+
                | a |      | a / b |
                +---+      +-------+
  mod         - Calculate the module and push the result back.
                +---+
                | b |
                +---+  ==> +---------+
                | a |      | a mod b |
                +---+      +---------+
  store       - store the topmost element in heap at the location specified by the next element in the stack.
                +---+
                | b |
                +---+  ==>                heap[a] = b
                | a |                 
                +---+      +---+
  retrieve    - retrieve value from the heap at the location specified by the stacks topmost element.
                +---+      +---------+
                | a |  ==> | heap[a] |           
                +---+      +---------+
  label    $l -
  call     $l -
  jmp      $l -
  jz       $l -
  jn       $l -
  ret         -
  end         - Terminate the program.
  printc      -
  printi      -
  readc       -
  readi       -

Where:
  $n - an integer parameter.
  $l - a label.

<a href="#top">[top]</a>
</div>

<a id="optimizer" />
<div>
Optimizer <a href="#top">[top]</a>
=========

The main philosophy behind the optimizer is that all Whitespace instructions are
equally slow. This means that all optimizations are made to reduce the number of
instructions. Optimizer guarantees that the number of instructions in the output
is less or equal to the original program.

As a secondary objective, the optimizer tries to reduce the size of the program to
speed up parsing. The optimizer does not guarantee that the output code is smaller
or equal in bytes compared to the initial program.

The optimizer works on the Whitespace instruction level, which means the assembly
programs can not be optimized directly - they have to be compiled into Whitespace.
This is a serious restriction by design.

Rules:
  * Remove unreachable code.
  * Inline unconditional jumps, if possible.
  * Inline function calls.
  * Remove unused and duplicate labels.
  * Mimimize label names by usage in the program.

<a href="#top">[top]</a>
</div>
</html>
